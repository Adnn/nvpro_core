/* auto generated by extensions_vk.lua */
/* Copyright (c) 2018, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <assert.h>
#include "extensions_vk.hpp"

/* loaders */
/* /////////////////////////////////// */
#if VK_KHR_push_descriptor
static PFN_vkCmdPushDescriptorSetKHR pfn_vkCmdPushDescriptorSetKHR = 0;
static PFN_vkCmdPushDescriptorSetWithTemplateKHR pfn_vkCmdPushDescriptorSetWithTemplateKHR = 0;

VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSetKHR(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    uint32_t                                    descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites)
{
  assert(pfn_vkCmdPushDescriptorSetKHR);
  pfn_vkCmdPushDescriptorSetKHR(commandBuffer,pipelineBindPoint,layout,set,descriptorWriteCount,pDescriptorWrites);
}
VKAPI_ATTR void VKAPI_CALL vkCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer                             commandBuffer,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    const void* pData)
{
  assert(pfn_vkCmdPushDescriptorSetWithTemplateKHR);
  pfn_vkCmdPushDescriptorSetWithTemplateKHR(commandBuffer,descriptorUpdateTemplate,layout,set,pData);
}

int load_VK_KHR_push_descriptor(VkDevice device, PFN_vkGetDeviceProcAddr getDeviceProcAddr)
{
  pfn_vkCmdPushDescriptorSetKHR = (PFN_vkCmdPushDescriptorSetKHR)getDeviceProcAddr(device, "vkCmdPushDescriptorSetKHR");
  pfn_vkCmdPushDescriptorSetWithTemplateKHR = (PFN_vkCmdPushDescriptorSetWithTemplateKHR)getDeviceProcAddr(device, "vkCmdPushDescriptorSetWithTemplateKHR");
  int success = 1;
  success = success && (pfn_vkCmdPushDescriptorSetKHR != 0);
  success = success && (pfn_vkCmdPushDescriptorSetWithTemplateKHR != 0);
  return success;
}
#endif

/* /////////////////////////////////// */
#if VK_NVX_device_generated_commands
static PFN_vkCmdProcessCommandsNVX pfn_vkCmdProcessCommandsNVX = 0;
static PFN_vkCmdReserveSpaceForCommandsNVX pfn_vkCmdReserveSpaceForCommandsNVX = 0;
static PFN_vkCreateIndirectCommandsLayoutNVX pfn_vkCreateIndirectCommandsLayoutNVX = 0;
static PFN_vkDestroyIndirectCommandsLayoutNVX pfn_vkDestroyIndirectCommandsLayoutNVX = 0;
static PFN_vkCreateObjectTableNVX pfn_vkCreateObjectTableNVX = 0;
static PFN_vkDestroyObjectTableNVX pfn_vkDestroyObjectTableNVX = 0;
static PFN_vkRegisterObjectsNVX pfn_vkRegisterObjectsNVX = 0;
static PFN_vkUnregisterObjectsNVX pfn_vkUnregisterObjectsNVX = 0;
static PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX pfn_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = 0;

VKAPI_ATTR void VKAPI_CALL vkCmdProcessCommandsNVX(
    VkCommandBuffer                             commandBuffer,
    const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo)
{
  assert(pfn_vkCmdProcessCommandsNVX);
  pfn_vkCmdProcessCommandsNVX(commandBuffer,pProcessCommandsInfo);
}
VKAPI_ATTR void VKAPI_CALL vkCmdReserveSpaceForCommandsNVX(
    VkCommandBuffer                             commandBuffer,
    const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo)
{
  assert(pfn_vkCmdReserveSpaceForCommandsNVX);
  pfn_vkCmdReserveSpaceForCommandsNVX(commandBuffer,pReserveSpaceInfo);
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateIndirectCommandsLayoutNVX(
    VkDevice                                    device,
    const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout)
{
  assert(pfn_vkCreateIndirectCommandsLayoutNVX);
  return pfn_vkCreateIndirectCommandsLayoutNVX(device,pCreateInfo,pAllocator,pIndirectCommandsLayout);
}
VKAPI_ATTR void VKAPI_CALL vkDestroyIndirectCommandsLayoutNVX(
    VkDevice                                    device,
    VkIndirectCommandsLayoutNVX                 indirectCommandsLayout,
    const VkAllocationCallbacks* pAllocator)
{
  assert(pfn_vkDestroyIndirectCommandsLayoutNVX);
  pfn_vkDestroyIndirectCommandsLayoutNVX(device,indirectCommandsLayout,pAllocator);
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateObjectTableNVX(
    VkDevice                                    device,
    const VkObjectTableCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkObjectTableNVX* pObjectTable)
{
  assert(pfn_vkCreateObjectTableNVX);
  return pfn_vkCreateObjectTableNVX(device,pCreateInfo,pAllocator,pObjectTable);
}
VKAPI_ATTR void VKAPI_CALL vkDestroyObjectTableNVX(
    VkDevice                                    device,
    VkObjectTableNVX                            objectTable,
    const VkAllocationCallbacks* pAllocator)
{
  assert(pfn_vkDestroyObjectTableNVX);
  pfn_vkDestroyObjectTableNVX(device,objectTable,pAllocator);
}
VKAPI_ATTR VkResult VKAPI_CALL vkRegisterObjectsNVX(
    VkDevice                                    device,
    VkObjectTableNVX                            objectTable,
    uint32_t                                    objectCount,
    const VkObjectTableEntryNVX* const* ppObjectTableEntries,
    const uint32_t* pObjectIndices)
{
  assert(pfn_vkRegisterObjectsNVX);
  return pfn_vkRegisterObjectsNVX(device,objectTable,objectCount,ppObjectTableEntries,pObjectIndices);
}
VKAPI_ATTR VkResult VKAPI_CALL vkUnregisterObjectsNVX(
    VkDevice                                    device,
    VkObjectTableNVX                            objectTable,
    uint32_t                                    objectCount,
    const VkObjectEntryTypeNVX* pObjectEntryTypes,
    const uint32_t* pObjectIndices)
{
  assert(pfn_vkUnregisterObjectsNVX);
  return pfn_vkUnregisterObjectsNVX(device,objectTable,objectCount,pObjectEntryTypes,pObjectIndices);
}
VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    VkPhysicalDevice                            physicalDevice,
    VkDeviceGeneratedCommandsFeaturesNVX* pFeatures,
    VkDeviceGeneratedCommandsLimitsNVX* pLimits)
{
  assert(pfn_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX);
  pfn_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice,pFeatures,pLimits);
}

int load_VK_NVX_device_generated_commands(VkDevice device, PFN_vkGetDeviceProcAddr getDeviceProcAddr)
{
  pfn_vkCmdProcessCommandsNVX = (PFN_vkCmdProcessCommandsNVX)getDeviceProcAddr(device, "vkCmdProcessCommandsNVX");
  pfn_vkCmdReserveSpaceForCommandsNVX = (PFN_vkCmdReserveSpaceForCommandsNVX)getDeviceProcAddr(device, "vkCmdReserveSpaceForCommandsNVX");
  pfn_vkCreateIndirectCommandsLayoutNVX = (PFN_vkCreateIndirectCommandsLayoutNVX)getDeviceProcAddr(device, "vkCreateIndirectCommandsLayoutNVX");
  pfn_vkDestroyIndirectCommandsLayoutNVX = (PFN_vkDestroyIndirectCommandsLayoutNVX)getDeviceProcAddr(device, "vkDestroyIndirectCommandsLayoutNVX");
  pfn_vkCreateObjectTableNVX = (PFN_vkCreateObjectTableNVX)getDeviceProcAddr(device, "vkCreateObjectTableNVX");
  pfn_vkDestroyObjectTableNVX = (PFN_vkDestroyObjectTableNVX)getDeviceProcAddr(device, "vkDestroyObjectTableNVX");
  pfn_vkRegisterObjectsNVX = (PFN_vkRegisterObjectsNVX)getDeviceProcAddr(device, "vkRegisterObjectsNVX");
  pfn_vkUnregisterObjectsNVX = (PFN_vkUnregisterObjectsNVX)getDeviceProcAddr(device, "vkUnregisterObjectsNVX");
  pfn_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = (PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX)getDeviceProcAddr(device, "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX");
  int success = 1;
  success = success && (pfn_vkCmdProcessCommandsNVX != 0);
  success = success && (pfn_vkCmdReserveSpaceForCommandsNVX != 0);
  success = success && (pfn_vkCreateIndirectCommandsLayoutNVX != 0);
  success = success && (pfn_vkDestroyIndirectCommandsLayoutNVX != 0);
  success = success && (pfn_vkCreateObjectTableNVX != 0);
  success = success && (pfn_vkDestroyObjectTableNVX != 0);
  success = success && (pfn_vkRegisterObjectsNVX != 0);
  success = success && (pfn_vkUnregisterObjectsNVX != 0);
  success = success && (pfn_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX != 0);
  return success;
}
#endif

/* /////////////////////////////////// */
#if VK_NVX_raytracing
static PFN_vkCreateAccelerationStructureNVX pfn_vkCreateAccelerationStructureNVX = 0;
static PFN_vkDestroyAccelerationStructureNVX pfn_vkDestroyAccelerationStructureNVX = 0;
static PFN_vkGetAccelerationStructureMemoryRequirementsNVX pfn_vkGetAccelerationStructureMemoryRequirementsNVX = 0;
static PFN_vkGetAccelerationStructureScratchMemoryRequirementsNVX pfn_vkGetAccelerationStructureScratchMemoryRequirementsNVX = 0;
static PFN_vkBindAccelerationStructureMemoryNVX pfn_vkBindAccelerationStructureMemoryNVX = 0;
static PFN_vkCmdBuildAccelerationStructureNVX pfn_vkCmdBuildAccelerationStructureNVX = 0;
static PFN_vkCmdCopyAccelerationStructureNVX pfn_vkCmdCopyAccelerationStructureNVX = 0;
static PFN_vkCmdTraceRaysNVX pfn_vkCmdTraceRaysNVX = 0;
static PFN_vkCreateRaytracingPipelinesNVX pfn_vkCreateRaytracingPipelinesNVX = 0;
static PFN_vkGetRaytracingShaderHandlesNVX pfn_vkGetRaytracingShaderHandlesNVX = 0;
static PFN_vkGetAccelerationStructureHandleNVX pfn_vkGetAccelerationStructureHandleNVX = 0;
static PFN_vkCmdWriteAccelerationStructurePropertiesNVX pfn_vkCmdWriteAccelerationStructurePropertiesNVX = 0;
static PFN_vkCompileDeferredNVX pfn_vkCompileDeferredNVX = 0;

VKAPI_ATTR VkResult VKAPI_CALL vkCreateAccelerationStructureNVX(
    VkDevice                                    device,
    const VkAccelerationStructureCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkAccelerationStructureNVX* pAccelerationStructure)
{
  assert(pfn_vkCreateAccelerationStructureNVX);
  return pfn_vkCreateAccelerationStructureNVX(device,pCreateInfo,pAllocator,pAccelerationStructure);
}
VKAPI_ATTR void VKAPI_CALL vkDestroyAccelerationStructureNVX(
    VkDevice                                    device,
    VkAccelerationStructureNVX                  accelerationStructure,
    const VkAllocationCallbacks* pAllocator)
{
  assert(pfn_vkDestroyAccelerationStructureNVX);
  pfn_vkDestroyAccelerationStructureNVX(device,accelerationStructure,pAllocator);
}
VKAPI_ATTR void VKAPI_CALL vkGetAccelerationStructureMemoryRequirementsNVX(
    VkDevice                                    device,
    const VkAccelerationStructureMemoryRequirementsInfoNVX* pInfo,
    VkMemoryRequirements2KHR* pMemoryRequirements)
{
  assert(pfn_vkGetAccelerationStructureMemoryRequirementsNVX);
  pfn_vkGetAccelerationStructureMemoryRequirementsNVX(device,pInfo,pMemoryRequirements);
}
VKAPI_ATTR void VKAPI_CALL vkGetAccelerationStructureScratchMemoryRequirementsNVX(
    VkDevice                                    device,
    const VkAccelerationStructureMemoryRequirementsInfoNVX* pInfo,
    VkMemoryRequirements2KHR* pMemoryRequirements)
{
  assert(pfn_vkGetAccelerationStructureScratchMemoryRequirementsNVX);
  pfn_vkGetAccelerationStructureScratchMemoryRequirementsNVX(device,pInfo,pMemoryRequirements);
}
VKAPI_ATTR VkResult VKAPI_CALL vkBindAccelerationStructureMemoryNVX(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindAccelerationStructureMemoryInfoNVX* pBindInfos)
{
  assert(pfn_vkBindAccelerationStructureMemoryNVX);
  return pfn_vkBindAccelerationStructureMemoryNVX(device,bindInfoCount,pBindInfos);
}
VKAPI_ATTR void VKAPI_CALL vkCmdBuildAccelerationStructureNVX(
    VkCommandBuffer                             cmdBuf,
    VkAccelerationStructureTypeNVX              type,
    uint32_t                                    instanceCount,
    VkBuffer                                    instanceData,
    VkDeviceSize                                instanceOffset,
    uint32_t                                    geometryCount,
    const VkGeometryNVX* pGeometries,
    VkBuildAccelerationStructureFlagsNVX        flags,
    VkBool32                                    update,
    VkAccelerationStructureNVX                  dst,
    VkAccelerationStructureNVX                  src,
    VkBuffer                                    scratch,
    VkDeviceSize                                scratchOffset)
{
  assert(pfn_vkCmdBuildAccelerationStructureNVX);
  pfn_vkCmdBuildAccelerationStructureNVX(cmdBuf,type,instanceCount,instanceData,instanceOffset,geometryCount,pGeometries,flags,update,dst,src,scratch,scratchOffset);
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyAccelerationStructureNVX(
    VkCommandBuffer                             cmdBuf,
    VkAccelerationStructureNVX                  dst,
    VkAccelerationStructureNVX                  src,
    VkCopyAccelerationStructureModeNVX          mode)
{
  assert(pfn_vkCmdCopyAccelerationStructureNVX);
  pfn_vkCmdCopyAccelerationStructureNVX(cmdBuf,dst,src,mode);
}
VKAPI_ATTR void VKAPI_CALL vkCmdTraceRaysNVX(
    VkCommandBuffer                             cmdBuf,
    VkBuffer                                    raygenShaderBindingTableBuffer,
    VkDeviceSize                                raygenShaderBindingOffset,
    VkBuffer                                    missShaderBindingTableBuffer,
    VkDeviceSize                                missShaderBindingOffset,
    VkDeviceSize                                missShaderBindingStride,
    VkBuffer                                    hitShaderBindingTableBuffer,
    VkDeviceSize                                hitShaderBindingOffset,
    VkDeviceSize                                hitShaderBindingStride,
    uint32_t                                    width,
    uint32_t                                    height)
{
  assert(pfn_vkCmdTraceRaysNVX);
  pfn_vkCmdTraceRaysNVX(cmdBuf,raygenShaderBindingTableBuffer,raygenShaderBindingOffset,missShaderBindingTableBuffer,missShaderBindingOffset,missShaderBindingStride,hitShaderBindingTableBuffer,hitShaderBindingOffset,hitShaderBindingStride,width,height);
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateRaytracingPipelinesNVX(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkRaytracingPipelineCreateInfoNVX* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
  assert(pfn_vkCreateRaytracingPipelinesNVX);
  return pfn_vkCreateRaytracingPipelinesNVX(device,pipelineCache,createInfoCount,pCreateInfos,pAllocator,pPipelines);
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetRaytracingShaderHandlesNVX(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    uint32_t                                    firstGroup,
    uint32_t                                    groupCount,
    size_t                                      dataSize,
    void* pData)
{
  assert(pfn_vkGetRaytracingShaderHandlesNVX);
  return pfn_vkGetRaytracingShaderHandlesNVX(device,pipeline,firstGroup,groupCount,dataSize,pData);
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetAccelerationStructureHandleNVX(
    VkDevice                                    device,
    VkAccelerationStructureNVX                  accelerationStructure,
    size_t                                      dataSize,
    void* pData)
{
  assert(pfn_vkGetAccelerationStructureHandleNVX);
  return pfn_vkGetAccelerationStructureHandleNVX(device,accelerationStructure,dataSize,pData);
}
VKAPI_ATTR void VKAPI_CALL vkCmdWriteAccelerationStructurePropertiesNVX(
    VkCommandBuffer                             cmdBuf,
    VkAccelerationStructureNVX                  accelerationStructure,
    VkQueryType                                 queryType,
    VkQueryPool                                 queryPool,
    uint32_t                                    query)
{
  assert(pfn_vkCmdWriteAccelerationStructurePropertiesNVX);
  pfn_vkCmdWriteAccelerationStructurePropertiesNVX(cmdBuf,accelerationStructure,queryType,queryPool,query);
}
VKAPI_ATTR VkResult VKAPI_CALL vkCompileDeferredNVX(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    uint32_t                                    shader)
{
  assert(pfn_vkCompileDeferredNVX);
  return pfn_vkCompileDeferredNVX(device,pipeline,shader);
}

int load_VK_NVX_raytracing(VkDevice device, PFN_vkGetDeviceProcAddr getDeviceProcAddr)
{
  pfn_vkCreateAccelerationStructureNVX = (PFN_vkCreateAccelerationStructureNVX)getDeviceProcAddr(device, "vkCreateAccelerationStructureNVX");
  pfn_vkDestroyAccelerationStructureNVX = (PFN_vkDestroyAccelerationStructureNVX)getDeviceProcAddr(device, "vkDestroyAccelerationStructureNVX");
  pfn_vkGetAccelerationStructureMemoryRequirementsNVX = (PFN_vkGetAccelerationStructureMemoryRequirementsNVX)getDeviceProcAddr(device, "vkGetAccelerationStructureMemoryRequirementsNVX");
  pfn_vkGetAccelerationStructureScratchMemoryRequirementsNVX = (PFN_vkGetAccelerationStructureScratchMemoryRequirementsNVX)getDeviceProcAddr(device, "vkGetAccelerationStructureScratchMemoryRequirementsNVX");
  pfn_vkBindAccelerationStructureMemoryNVX = (PFN_vkBindAccelerationStructureMemoryNVX)getDeviceProcAddr(device, "vkBindAccelerationStructureMemoryNVX");
  pfn_vkCmdBuildAccelerationStructureNVX = (PFN_vkCmdBuildAccelerationStructureNVX)getDeviceProcAddr(device, "vkCmdBuildAccelerationStructureNVX");
  pfn_vkCmdCopyAccelerationStructureNVX = (PFN_vkCmdCopyAccelerationStructureNVX)getDeviceProcAddr(device, "vkCmdCopyAccelerationStructureNVX");
  pfn_vkCmdTraceRaysNVX = (PFN_vkCmdTraceRaysNVX)getDeviceProcAddr(device, "vkCmdTraceRaysNVX");
  pfn_vkCreateRaytracingPipelinesNVX = (PFN_vkCreateRaytracingPipelinesNVX)getDeviceProcAddr(device, "vkCreateRaytracingPipelinesNVX");
  pfn_vkGetRaytracingShaderHandlesNVX = (PFN_vkGetRaytracingShaderHandlesNVX)getDeviceProcAddr(device, "vkGetRaytracingShaderHandlesNVX");
  pfn_vkGetAccelerationStructureHandleNVX = (PFN_vkGetAccelerationStructureHandleNVX)getDeviceProcAddr(device, "vkGetAccelerationStructureHandleNVX");
  pfn_vkCmdWriteAccelerationStructurePropertiesNVX = (PFN_vkCmdWriteAccelerationStructurePropertiesNVX)getDeviceProcAddr(device, "vkCmdWriteAccelerationStructurePropertiesNVX");
  pfn_vkCompileDeferredNVX = (PFN_vkCompileDeferredNVX)getDeviceProcAddr(device, "vkCompileDeferredNVX");
  int success = 1;
  success = success && (pfn_vkCreateAccelerationStructureNVX != 0);
  success = success && (pfn_vkDestroyAccelerationStructureNVX != 0);
  success = success && (pfn_vkGetAccelerationStructureMemoryRequirementsNVX != 0);
  success = success && (pfn_vkGetAccelerationStructureScratchMemoryRequirementsNVX != 0);
  success = success && (pfn_vkBindAccelerationStructureMemoryNVX != 0);
  success = success && (pfn_vkCmdBuildAccelerationStructureNVX != 0);
  success = success && (pfn_vkCmdCopyAccelerationStructureNVX != 0);
  success = success && (pfn_vkCmdTraceRaysNVX != 0);
  success = success && (pfn_vkCreateRaytracingPipelinesNVX != 0);
  success = success && (pfn_vkGetRaytracingShaderHandlesNVX != 0);
  success = success && (pfn_vkGetAccelerationStructureHandleNVX != 0);
  success = success && (pfn_vkCmdWriteAccelerationStructurePropertiesNVX != 0);
  success = success && (pfn_vkCompileDeferredNVX != 0);
  return success;
}
#endif

/* /////////////////////////////////// */
#if VK_NV_ray_tracing
static PFN_vkCreateAccelerationStructureNV pfn_vkCreateAccelerationStructureNV = 0;
static PFN_vkDestroyAccelerationStructureNV pfn_vkDestroyAccelerationStructureNV = 0;
static PFN_vkGetAccelerationStructureMemoryRequirementsNV pfn_vkGetAccelerationStructureMemoryRequirementsNV = 0;
static PFN_vkBindAccelerationStructureMemoryNV pfn_vkBindAccelerationStructureMemoryNV = 0;
static PFN_vkCmdBuildAccelerationStructureNV pfn_vkCmdBuildAccelerationStructureNV = 0;
static PFN_vkCmdCopyAccelerationStructureNV pfn_vkCmdCopyAccelerationStructureNV = 0;
static PFN_vkCmdTraceRaysNV pfn_vkCmdTraceRaysNV = 0;
static PFN_vkCreateRayTracingPipelinesNV pfn_vkCreateRayTracingPipelinesNV = 0;
static PFN_vkGetRayTracingShaderGroupHandlesNV pfn_vkGetRayTracingShaderGroupHandlesNV = 0;
static PFN_vkGetAccelerationStructureHandleNV pfn_vkGetAccelerationStructureHandleNV = 0;
static PFN_vkCmdWriteAccelerationStructuresPropertiesNV pfn_vkCmdWriteAccelerationStructuresPropertiesNV = 0;
static PFN_vkCompileDeferredNV pfn_vkCompileDeferredNV = 0;

VKAPI_ATTR VkResult VKAPI_CALL vkCreateAccelerationStructureNV(
    VkDevice                                    device,
    const VkAccelerationStructureCreateInfoNV* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkAccelerationStructureNV* pAccelerationStructure)
{
  assert(pfn_vkCreateAccelerationStructureNV);
  return pfn_vkCreateAccelerationStructureNV(device,pCreateInfo,pAllocator,pAccelerationStructure);
}
VKAPI_ATTR void VKAPI_CALL vkDestroyAccelerationStructureNV(
    VkDevice                                    device,
    VkAccelerationStructureNV                   accelerationStructure,
    const VkAllocationCallbacks* pAllocator)
{
  assert(pfn_vkDestroyAccelerationStructureNV);
  pfn_vkDestroyAccelerationStructureNV(device,accelerationStructure,pAllocator);
}
VKAPI_ATTR void VKAPI_CALL vkGetAccelerationStructureMemoryRequirementsNV(
    VkDevice                                    device,
    const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo,
    VkMemoryRequirements2KHR* pMemoryRequirements)
{
  assert(pfn_vkGetAccelerationStructureMemoryRequirementsNV);
  pfn_vkGetAccelerationStructureMemoryRequirementsNV(device,pInfo,pMemoryRequirements);
}
VKAPI_ATTR VkResult VKAPI_CALL vkBindAccelerationStructureMemoryNV(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindAccelerationStructureMemoryInfoNV* pBindInfos)
{
  assert(pfn_vkBindAccelerationStructureMemoryNV);
  return pfn_vkBindAccelerationStructureMemoryNV(device,bindInfoCount,pBindInfos);
}
VKAPI_ATTR void VKAPI_CALL vkCmdBuildAccelerationStructureNV(
    VkCommandBuffer                             commandBuffer,
    const VkAccelerationStructureInfoNV* pInfo,
    VkBuffer                                    instanceData,
    VkDeviceSize                                instanceOffset,
    VkBool32                                    update,
    VkAccelerationStructureNV                   dst,
    VkAccelerationStructureNV                   src,
    VkBuffer                                    scratch,
    VkDeviceSize                                scratchOffset)
{
  assert(pfn_vkCmdBuildAccelerationStructureNV);
  pfn_vkCmdBuildAccelerationStructureNV(commandBuffer,pInfo,instanceData,instanceOffset,update,dst,src,scratch,scratchOffset);
}
VKAPI_ATTR void VKAPI_CALL vkCmdCopyAccelerationStructureNV(
    VkCommandBuffer                             commandBuffer,
    VkAccelerationStructureNV                   dst,
    VkAccelerationStructureNV                   src,
    VkCopyAccelerationStructureModeNV           mode)
{
  assert(pfn_vkCmdCopyAccelerationStructureNV);
  pfn_vkCmdCopyAccelerationStructureNV(commandBuffer,dst,src,mode);
}
VKAPI_ATTR void VKAPI_CALL vkCmdTraceRaysNV(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    raygenShaderBindingTableBuffer,
    VkDeviceSize                                raygenShaderBindingOffset,
    VkBuffer                                    missShaderBindingTableBuffer,
    VkDeviceSize                                missShaderBindingOffset,
    VkDeviceSize                                missShaderBindingStride,
    VkBuffer                                    hitShaderBindingTableBuffer,
    VkDeviceSize                                hitShaderBindingOffset,
    VkDeviceSize                                hitShaderBindingStride,
    VkBuffer                                    callableShaderBindingTableBuffer,
    VkDeviceSize                                callableShaderBindingOffset,
    VkDeviceSize                                callableShaderBindingStride,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth)
{
  assert(pfn_vkCmdTraceRaysNV);
  pfn_vkCmdTraceRaysNV(commandBuffer,raygenShaderBindingTableBuffer,raygenShaderBindingOffset,missShaderBindingTableBuffer,missShaderBindingOffset,missShaderBindingStride,hitShaderBindingTableBuffer,hitShaderBindingOffset,hitShaderBindingStride,callableShaderBindingTableBuffer,callableShaderBindingOffset,callableShaderBindingStride,width,height,depth);
}
VKAPI_ATTR VkResult VKAPI_CALL vkCreateRayTracingPipelinesNV(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkRayTracingPipelineCreateInfoNV* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
  assert(pfn_vkCreateRayTracingPipelinesNV);
  return pfn_vkCreateRayTracingPipelinesNV(device,pipelineCache,createInfoCount,pCreateInfos,pAllocator,pPipelines);
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetRayTracingShaderGroupHandlesNV(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    uint32_t                                    firstGroup,
    uint32_t                                    groupCount,
    size_t                                      dataSize,
    void* pData)
{
  assert(pfn_vkGetRayTracingShaderGroupHandlesNV);
  return pfn_vkGetRayTracingShaderGroupHandlesNV(device,pipeline,firstGroup,groupCount,dataSize,pData);
}
VKAPI_ATTR VkResult VKAPI_CALL vkGetAccelerationStructureHandleNV(
    VkDevice                                    device,
    VkAccelerationStructureNV                   accelerationStructure,
    size_t                                      dataSize,
    void* pData)
{
  assert(pfn_vkGetAccelerationStructureHandleNV);
  return pfn_vkGetAccelerationStructureHandleNV(device,accelerationStructure,dataSize,pData);
}
VKAPI_ATTR void VKAPI_CALL vkCmdWriteAccelerationStructuresPropertiesNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    accelerationStructureCount,
    const VkAccelerationStructureNV* pAccelerationStructures,
    VkQueryType                                 queryType,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery)
{
  assert(pfn_vkCmdWriteAccelerationStructuresPropertiesNV);
  pfn_vkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer,accelerationStructureCount,pAccelerationStructures,queryType,queryPool,firstQuery);
}
VKAPI_ATTR VkResult VKAPI_CALL vkCompileDeferredNV(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    uint32_t                                    shader)
{
  assert(pfn_vkCompileDeferredNV);
  return pfn_vkCompileDeferredNV(device,pipeline,shader);
}

int load_VK_NV_ray_tracing(VkDevice device, PFN_vkGetDeviceProcAddr getDeviceProcAddr)
{
  pfn_vkCreateAccelerationStructureNV = (PFN_vkCreateAccelerationStructureNV)getDeviceProcAddr(device, "vkCreateAccelerationStructureNV");
  pfn_vkDestroyAccelerationStructureNV = (PFN_vkDestroyAccelerationStructureNV)getDeviceProcAddr(device, "vkDestroyAccelerationStructureNV");
  pfn_vkGetAccelerationStructureMemoryRequirementsNV = (PFN_vkGetAccelerationStructureMemoryRequirementsNV)getDeviceProcAddr(device, "vkGetAccelerationStructureMemoryRequirementsNV");
  pfn_vkBindAccelerationStructureMemoryNV = (PFN_vkBindAccelerationStructureMemoryNV)getDeviceProcAddr(device, "vkBindAccelerationStructureMemoryNV");
  pfn_vkCmdBuildAccelerationStructureNV = (PFN_vkCmdBuildAccelerationStructureNV)getDeviceProcAddr(device, "vkCmdBuildAccelerationStructureNV");
  pfn_vkCmdCopyAccelerationStructureNV = (PFN_vkCmdCopyAccelerationStructureNV)getDeviceProcAddr(device, "vkCmdCopyAccelerationStructureNV");
  pfn_vkCmdTraceRaysNV = (PFN_vkCmdTraceRaysNV)getDeviceProcAddr(device, "vkCmdTraceRaysNV");
  pfn_vkCreateRayTracingPipelinesNV = (PFN_vkCreateRayTracingPipelinesNV)getDeviceProcAddr(device, "vkCreateRayTracingPipelinesNV");
  pfn_vkGetRayTracingShaderGroupHandlesNV = (PFN_vkGetRayTracingShaderGroupHandlesNV)getDeviceProcAddr(device, "vkGetRayTracingShaderGroupHandlesNV");
  pfn_vkGetAccelerationStructureHandleNV = (PFN_vkGetAccelerationStructureHandleNV)getDeviceProcAddr(device, "vkGetAccelerationStructureHandleNV");
  pfn_vkCmdWriteAccelerationStructuresPropertiesNV = (PFN_vkCmdWriteAccelerationStructuresPropertiesNV)getDeviceProcAddr(device, "vkCmdWriteAccelerationStructuresPropertiesNV");
  pfn_vkCompileDeferredNV = (PFN_vkCompileDeferredNV)getDeviceProcAddr(device, "vkCompileDeferredNV");
  int success = 1;
  success = success && (pfn_vkCreateAccelerationStructureNV != 0);
  success = success && (pfn_vkDestroyAccelerationStructureNV != 0);
  success = success && (pfn_vkGetAccelerationStructureMemoryRequirementsNV != 0);
  success = success && (pfn_vkBindAccelerationStructureMemoryNV != 0);
  success = success && (pfn_vkCmdBuildAccelerationStructureNV != 0);
  success = success && (pfn_vkCmdCopyAccelerationStructureNV != 0);
  success = success && (pfn_vkCmdTraceRaysNV != 0);
  success = success && (pfn_vkCreateRayTracingPipelinesNV != 0);
  success = success && (pfn_vkGetRayTracingShaderGroupHandlesNV != 0);
  success = success && (pfn_vkGetAccelerationStructureHandleNV != 0);
  success = success && (pfn_vkCmdWriteAccelerationStructuresPropertiesNV != 0);
  success = success && (pfn_vkCompileDeferredNV != 0);
  return success;
}
#endif

/* /////////////////////////////////// */
#if VK_NV_mesh_shader
static PFN_vkCmdDrawMeshTasksNV pfn_vkCmdDrawMeshTasksNV = 0;
static PFN_vkCmdDrawMeshTasksIndirectNV pfn_vkCmdDrawMeshTasksIndirectNV = 0;
static PFN_vkCmdDrawMeshTasksIndirectCountNV pfn_vkCmdDrawMeshTasksIndirectCountNV = 0;

VKAPI_ATTR void VKAPI_CALL vkCmdDrawMeshTasksNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    taskCount,
    uint32_t                                    firstTask)
{
  assert(pfn_vkCmdDrawMeshTasksNV);
  pfn_vkCmdDrawMeshTasksNV(commandBuffer,taskCount,firstTask);
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawMeshTasksIndirectNV(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
  assert(pfn_vkCmdDrawMeshTasksIndirectNV);
  pfn_vkCmdDrawMeshTasksIndirectNV(commandBuffer,buffer,offset,drawCount,stride);
}
VKAPI_ATTR void VKAPI_CALL vkCmdDrawMeshTasksIndirectCountNV(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
  assert(pfn_vkCmdDrawMeshTasksIndirectCountNV);
  pfn_vkCmdDrawMeshTasksIndirectCountNV(commandBuffer,buffer,offset,countBuffer,countBufferOffset,maxDrawCount,stride);
}

int load_VK_NV_mesh_shader(VkDevice device, PFN_vkGetDeviceProcAddr getDeviceProcAddr)
{
  pfn_vkCmdDrawMeshTasksNV = (PFN_vkCmdDrawMeshTasksNV)getDeviceProcAddr(device, "vkCmdDrawMeshTasksNV");
  pfn_vkCmdDrawMeshTasksIndirectNV = (PFN_vkCmdDrawMeshTasksIndirectNV)getDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectNV");
  pfn_vkCmdDrawMeshTasksIndirectCountNV = (PFN_vkCmdDrawMeshTasksIndirectCountNV)getDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectCountNV");
  int success = 1;
  success = success && (pfn_vkCmdDrawMeshTasksNV != 0);
  success = success && (pfn_vkCmdDrawMeshTasksIndirectNV != 0);
  success = success && (pfn_vkCmdDrawMeshTasksIndirectCountNV != 0);
  return success;
}
#endif


